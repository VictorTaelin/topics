Notation: 
  {::t} arbitrary function of type t; typically the function being tested.
  (::t) given function of type t: typically the specification.
  (::) given function of matching type; please infer.
  

Simple form of a property:

prop x = {::t} x == (::t) x

There are two types of args given to a tested function; randomized ones and canonical ones.
However; we can for the moment imagine that canonical ones (non types) can be randomized once
we have fixed the type argument.


-- Playing with bools.
t ≡ a -> Bool
a ≡ 1



t ≡ (a -> Bool, a) -> Bool
exampleFunction (f, a) = not (f a)
a ≡ 2 


-- Length
prop0 :: [a] -> Bool
prop0 xs = {::[a]->Int} xs == (::[a]->Int) xs


prop1 :: a -> Set a -> Bool
prop1 x xs = 1 + {::Set a -> Int} xs == length (x:xs)

a ≡ 1


-- Transitivity
prop :: (a -> a -> Bool) -> a -> a -> a -> Bool
prop (==) x y z = {::} (==) x y z == (::) (==) x y z
a ≡ 2
(==) = structural eq.

-- reverse
prop1 :: (a -> a -> Bool) -> [a] -> Bool
prop1 (==) x = and $ zipWith (==) $ (reverse (reverse x)) x

a ≡ 2

'a' appears as 2nd level argument... i.e. something can be observed in it.

-----------
-- Sort

prop1 :: Ord a => [a] -> Bool
prop1 x = let y = sort x in i <= j ==> y !! i <= y !! j

ridding of t.c.

sort' cmp [] = []
sort' cmp (x:xs) = sort l ++ x : sort r
 where (l,r) = partition (cmp x) xs

prop1 :: (a -> a -> Bool) -> (a -> a -> Bool) -> [a] -> Bool
prop1 (.<=.) (.==.) x = let y = sort' (.<=.) x in i <= j ==> y !! i .<=. y !! j


-----------------

 stable sort vs. sort


------------------


forall h (relation), forall f g, f == g . (h × h) ⇒  map h . sort f == sort g . map h

f = standard comparison of Int
g = standard comparison of Bool

f = should I swap?
g = should I swap?

theorem: (sort g correct ==> sort f correct.)


suppose the converse, derive absurd.

converse 
  == not (sort g correct ==> sort f correct)
  == sort g correct && sort f incorrect


Suppose that xs contains x and y and x < y


sort f incorrect ==> exists x < y and y before x in sort f xs

let h (the relation) be defined by

   h n = {y <= n,


we verify the premise: g . (h × h) == f

let y = 10

x       f x   (h × h) x       (g . h×h) x
5,1     T     T,T             F                      

oops!


